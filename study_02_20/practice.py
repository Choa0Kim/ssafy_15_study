# def recur(num): # num: 받을 인자(2로 나눈 몫)
#     #2.  종료 조건
#     if num == 0:
#         return num 
#     # 3. 다음 턴에 반환할 값
#     recur(num//2)
#     # 4. 재귀가 한 번 돌고 누적할 값.(결과)
#     print(num % 2, end = '')


# N = int(input())
# #1. 시작점: 해당 숫자부터 시작


# 자료구조 이해
# - 탐색/삽입/삭제 원리(그림으로 그려보자)
#   - 수정은 고려하지 않는 자료구조들
#   - 시간 복잡도까지 이해
# - 라이브러리 쓰는 법(힙)


# 이진 탐색 트리
# - 기본성질 (정렬된 상태를 유지함)
#   - 왼쪽 서브트리: 현재 노드보다 작은 값
#   - 오른쪽 서브트리: 현재 노드보다 큰 값

# 탐색연산
# 높이가 가장 낮게 나오는 케이스
# - 균형 잡히게 데이터 입력
# 높이가 가장 높게 나오는 케이스
# - 오름차순/내림차순에 가까울수록 높음
# 한 칸 아래로 갈수록 탐색범위가 절반씩 없어진다. 
# 탐색하는 시간 - 트리의 높이게 비례(높을수록 시간 증가)

# 삽입 연산
#- 본인 자리를 탐색에서 삽입

# 삭제 연산
# - 부모노드가 삭제되었을때,
#   - 왼쪽 서브트리 중에서 가장 큰 수
#   - 오른쪽 서브트리 중에서 가장 작은 수
# 1. 자식노드가 없는 노드를 삭제
# - 그냥 삭제
# 2. 자식 노드가 1개인 노드를 삭제
# - 자식을 부모와 연결 후 삭제
# 3. 자식 노드가 2개인 노드를 삭제
# - 왼쪽 자식 중 가장 큰 노드
# - 오른쪽 자식 중 가장 작은 노드가 해당 자리 차지

# 이진 트리 높이의 특성
# - 데이터 N개를 이진트리로 구성
#   -높이가 가장 낮을 때
#    - 완전 이진 트리에 가까울 때
#   - 높이가 가장 높을 떄
#     - 편향 이진 트리에 가까울 때
#     - 높이 = N에 가까움

# 힙
# - 기본 성질(정렬된 상태를 유지)
#   - 부모가 자식노드들보다 크다(작음)
# - 목적: 가장 크거나 작은 데이터부터 조회하려고 쓰는 자료구조
#   - 중간 데이터는 고려X
#   - 가장 앞에 있는 데이터만 정렬된 상태(형제노드 끼리는 정렬X)
#- 시간복잡도:O(logN) 
#- 완전 이진트리

# - 삽입 연산
# - 일단 맨 뒤에 넣고, 이후에 자리를 찾아감.

# - 삭제 연산
# - 제일 위 데이터를 어딘가 저장함
# - 가장 마지막 데이터를 제일 위로 이동
# 자식 중에 더 큰 값이랑 swap하면서 자기 자리를 찾아감.


# 삭제/삽입 과정설명 => 시험


#heapq 
#-기본이 최소 힙(최대 값은 -로 지정)
# heappush/heappop

# 1. 트리개념/ 트리 순회 
# -전위/중위/후위
#2. 힙, 이진탐색트리



