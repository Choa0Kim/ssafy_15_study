# ----------- 라이브 수업-----------------
# 배열 원소의 합 s 계산
arr =[]
s = 0
for i in range(N):
    s += arr[i]


# 배열 원소 중 최댓값의 인덱스 max_idx
max_idx = 0  # 첫 원소를 최대로 가정 

for i in range(1, N):
    if arr[max_idx] < arr[i]:  #  더 큰 값을 만나면 
        max_idx = i            #  max_idx 갱신. 같은 값을 만나면 무시함.

# 배열 원소 중 최대값의 인덱스 max_idx 찾기 - 최대값이 여러개 인 경우
max_idx = 0

for i in range(1, N):
    if arr[max_idx] <= arr[i]:
        max_idx = i   #  같은 값일때도 갱신

# 최초의 인덱스 값을 찾는 경우


# 찾는 값이 배열에 있으면 해당 원소의 인덱스, 없으면 -1 넣기
# 입력예시
# 6 5
# 2 7 5 3 1 7

# 입력 받기
N, V = map(int, input().split())
arr = list(map(int, input().split()))

idx = -1            # 찾는 값이 없다고 가정
for i in range(N):
    if arr[i] == V:  #arr[i]가 찾는 값이면
        idx = i    # 인덱스 저장
        break #  for i를 중시 시킴


# 연습문제 1
# N개의 양의 정수에서 가장 큰 수와 가장 작은 수의 차이를 출력
# 입력예시
# 3  ()
# 5  ()
# 477162 658880 751280 927930 297191




#  버블 정렬
# 예시 a =[55, 7, 78, 12, 42] - 오름차순으로 정리하기
# 1. 구간의 끝을 표시하는 인덱스 설정
def bubblesort(a, N):    #  정렬할 list, N 원소 수
    for i in range(N-1, 0, -1):  #범위의 끝 위치(맨 뒤에서 )
        for j in range(i):     # 비교할 왼쪽 원소 인덱스 j
            if a[j] > a[j+1] :
                a[j], a[j+1] = a[j+1], a[j]



# ---------- 오프라인 수업---------------

#### 개발자로서 기본기 ####
# 0. 문법
# 1. 버그가 발생(에디터의 디버깅 툴 활용)
# - 어떻게 빨리 파악하는가
# - 어떻게 수정할 지 방향성으 잡는 것

# 2. 효율적인 코드를 작성 (스스로 계산하는 방법)
# - 시간적인 효율 (연산속도, 시간복잡도/ 빅-오 표기법)
# - 메모리적인 효율

# 3. 숨겨진 문제점을 예측
# - 히든 테스트케이스를 만들 수 있는지?


#  SWEA 에서 과제는 1문제 이상
# 1.
# - 필수과제 해결
# - 수업내용 따라오기
# 2.
# - SWEA 추가문제들
# 3.
# - 문제집 참고로 문제풀이

# im 테스트 - 2/19 - SWEA 시크릿문제집 공부





###### 알고리즘 ######
# 빅-오 표기법
#  알고리즘의 시간
# 공통점
# - 입력값에 따라 연산횟수가 달라진다.
#   - 항상 입력갑에 따라 알고리즘이 시간이 결정
#   - 가장 큰 입력값(최악의 케이스)을 기준으로 구현
#   - 실제로 몇 번 연산이 되는지?

# - 두루뭉실하게 설명(대략적으로 이정도 됩니다.)
#  - 입력 N에 대하여 어느정도 비례합니다
#  예시) 1:1 비율로 증가 => 빅오표가법: O(N)
#       O(N):
#       N = int(inpit())
        # for i in range(N):
        #     print(i)

#  1중 for문 : N이 늘어나면 연산횟수가 N번 늘어남 == O(N)
#  2중 for 문 : N X N 번 늘어남 == O(N^2)

# 실제 연산: 3N + 10
# 빅오표기법:
# O(3N + 10) ->O(N)
# N 값이 무한대에 가깝다고 가정한 표기법

# 실제 연산 횟수: N^2 + N + 10
# 빅오 표기법: O(N^2)
# N = 10 + 100 + 10 = 120 번

for i in range(N):   # 10번
    print(i)

for i in range(N):
    for j in range(N):   #100번
        print(i)

for i in range(10):
    print(10)            #10번


# 실제 연산횟수 : N
# 빅오 표기법: O(N)
# 항상 빅오 표기법을 믿으면 안됨.

N = 1000
for i in range(N):  #1000 번 연산
    print(i)

for i in range(100,000,000):  #1억번 연산
    print(i) 

   
# python 
# - 속도는 느리지만
# - 메모리를 효율적으로 쓴다
#   => 재귀 호출

# pypy(채점 사이트)
# - 속도는 빠르지만
# - 메모리는 비효율적


#          










